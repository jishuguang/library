# 并发

## 概述

Approches to concurrency:
- multiple processes
- multiple threads

Why use concurrency:
- for separation of concerns
- for performance: task and data parallelism

## 线程管理

Basic thread managment
- Launch: `std::thread` constructor
- Wait or not：`join` or `detach`

Passing args
- copy
- std::move
- std::ref
- object pointer for member function

Thread ownership
- movable
- `std::jthread`

Thread amount
- `std::thread::hardware_concurrency()`

Identifying thread
- `std::thread::get_id()`
- `std::this_thread::get_id()`

## 线程共享数据

Problem
- race condition
- broken invariant

Avoid race condition
- wrap structure under protection guard
- refine structure using lock-free programming
- software transactional memory (STM)

### Mutex

Using mutex
- `std::mutex`
- `std::lock_guard`
    - `std::adopt_lock`

Avoid deadlock
- avoid nested lock
- avoid calling user-supplied code while holding a lock
- acquire lock in a fixed order
    - `std::lock`
    - `std::scoped_lock`
    - hand-over-hand locking
    - use a lock hierachy

`std::unique_lock`
- slight larger and slower than `std::lock_guard`
- use case
    - `std::defer_lock`
    - transfer ownership (moveable / not copyable)
    - flexible locking: doesn’t always own the mutex

Attention
- Don’t pass pointers and references to protected data outside the scope of the lock
- lock granularity
    - minimum necessary data
    - minimum possible time

### Alternative facilities



## 参考资料

- C++ Concurrency in Action 2nd Edition