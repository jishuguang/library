# 模板进阶

## Fundamentals

### Declaration

Union Template

```cpp
template<typename T>
union AllocChunk {
    T object;
    unsigned char bytes[sizeof(T)];
};
```

Default Call Arguments
- Function templates can have default call arguments just like ordinary function declarations

Virtual Member Functions
- Member function templates cannot be declared virtual
- for virtual function call mechanism uses a fixed-size table

Templates usually have external linkage. The only exceptions：
- namespace scope function templates with the static specifier
- templates that are direct or indirect members of an unnamed name-space
- member templates of unnamed classes

### Template parameters

Type parameter
- it is not possible to use an elaborated name of the form `class T` when `T` is a template parameter

Nontype parameter must be one of the following:
- An integer type or an enumeration type
- A pointer type
- A pointer-to-member type
- An lvalue reference type
- std::nullptr_t
- A type containing auto or decltype(auto)

Template template parameter
- The parameters of template template parameters can have default template arguments
- the names of the template parameter of the template template parameter can be used only in the declaration of other parameters of that template template parameter

Tempalte pack
- Primary template parameter pack must be the last template parameter.
- Primary Function templates have a weaker restriction:
    - Multiple template parameter packs are permitted, as long as each template parameter subsequent to a template parameter pack either has a default value or can be deduced
- Declarations of partial specializations of class and variable templates can have multiple parameter packs

Default Template Arguments
- A number of contexts do not permit default template arguments:
    - Partial specializations
    - Parameter packs
    - out-of-class definition of a member of a class template
    - A friend class template declaration （unless it is a definition and no declaration of it appears anywhere else in the translation unit）

### Template Arguments

Some template arguments can never be deduced because:
- their corresponding template parameter does not appear in a function parameter type

A general constraint of template arguments is that a compiler or a linker must be able to express their value when the program is being built.

some constant values that are not currently valid:
- Floating-point numbers
- String literals

A function generated from a function template is never equivalent to an ordinary function even though they may have the same type and the same name:
- A function generated from a member function template never overrides a virtual function.
- A constructor generated from a constructor template is never a copy or move constructor.

### Variadic Templates

Pack expansion
- pattern: typically comes before the ellipsis that denotes the pack expansion
- Where Can Pack Expansions Occur
    - can be used essentially anywhere in the language where the grammar provides a comma-separated list

Parameter packs:
- Template parameter packs
- Function Parameter Packs

Multiple and Nested Pack Expansions
```cpp
template<typename... OuterTypes>
class Nested {
    template<typename... InnerTypes>
    void f(InnerTypes const&... innerValues) {
        g(OuterTypes(InnerTypes(innerValues)...)...);
    }
};
```

Zero-Length Pack Expansions
- Pack expansions are actually semantic constructs, and the substitution of an argument pack of any size does not affect how the pack expansion is parsed
- when a pack expansion expands to an empty list, the program behaves (semantically) as if the list were not present.
    - base class: `class Point : public Mixins…`
    - variable initilization vs function declaration: `T v(values…)`

Fold Expressions
- three exceptions:
    - An empty expansion of a unary fold of `&&` produces the value `true`
    - An empty expansion of a unary fold of `||` produces the value `false`
    - An empty expansion of a unary fold of the comma operator `(,)` produces a `void` expression

### Friends

Friend Classes of Class Templates
- declaration of other class template instantiations to be friends
```cpp
template<typename T>
class Stack {
    template<typename> friend class Stack;
};
```

Friend Functions of Class Templates
- An instance of a function template can be made a friend
```cpp
template<typename T1, typename T2>
void combine(T1, T2);

class Mixer {
    // cannot define a template instance
    friend void combine<>(int&, int&);
    friend void combine<int, int>(int, int);
}
```
- A friend function may also be defined within a class template
```cpp
template<typename T>
class Creator {
    friend void feed(Creator<T>) { /*every T instantiates a different function ::feed()*/ }
}
```

- Friend Templates
    - all instances of a template are friends of a class
```cpp
class Manager {
    template<typename T>
    friend class Task;
    
    template<typename T>
    friend void Schedule<T>::dispatch(Task<T>*);
};
```

## Names in templates

### Name taxonomy

two major naming concepts:
- qualified name
    - Unqualified id
        - Identifier
        - Operator function-id
        - Conversion function-id
        - Literal operator-id
        - Template-id
        - a “destructor name”
    - Qualified-id: qualified with the name of a class, enum, or namespace, or just with the global scope resolution operator
    - Qualified name
        - a qualifiedid 
        - or an unqualified-id that is used after an explicit member access operator `(. or ->)`
    - Unqualified name: An unqualified-id that is not a qualified name
- dependent name
    - contains a template parameter
    - a qualified name that is qualified by a member access operator (.or ->) and the type of the expression on the left of the access operator is type-dependent
    - a name that is subject to argument-dependent lookup and any of the argument expressions is type-dependent

### Looking Up Names

Basis
- Qualified names are looked up in the scope implied by the qualifying construct
    - If that scope is a class, then base classes may also be searched
- unqualified names are typically looked up in successively more enclosing scopes （**ordinary lookup**）
    - in member function definitions, the scope of the class and its base classes is searched before any other enclosing scopes

Argument-dependent lookup (ADL)
- ADL proceeds by looking up the name in namespaces and classes “associated with” the types of the call arguments
- Argument-Dependent Lookup of Friend Declarations

Injected Class Names
- The name of a class is injected inside the scope of that class itself
- However, it is not accessible as a qualified name because this is the notation used to denote the constructors
- Within a class template, the injected class name or any type that is equivalent to the injected class name of any enclosing class or class template is said to refer to a current instantiation

### Parsing Templates

Context Sensitivity in Nontemplate
- To handle context sensitivity, a C++ compiler will couple a symbol table to the tokenizer and parser

Dependent Names of Types
- one template cannot look into another template because the contents of that other template can be made invalid by an explicit specialization.
- The language definition resolves this problem by specifying that in general a dependent qualified name does not denote a type unless that name is prefixed with the keyword `typename`

Dependent Names of Templates
- a compiler has to assume that a dependent name does not refer to a template unless the programmer provides extra information using the keyword `template`

Dependent Names in Using Declarations
- if we want a dependent name to be brought in by a using declaration to denote a type, we must explicitly say so by inserting the keyword `typename`

ADL and Explicit Template Arguments

Dependent Expressions
- type-dependent expression
- value-dependent expression
- some operations, such as `sizeof`, have a known result type, so they can turn a type-dependent operand into a value-dependent expression
- Any expression that involves a template parameter is an instantiation-dependent expression

Compiler Errors
- A C++ compiler is permitted (but not required!) to diagnose errors at the time the template is parsed when all of the instantiations of the template would produce that error.

### Inheritance and Class Templates

Nondependent Base Classes
- a nondependent base class is one with a complete type that can be determined without knowing the template arguments
- When an unqualified name is looked up in the templated derivation, the nondependent bases are considered before the list of template parameters.
```cpp
template<typename T>
class D2 : public Base<double> { //nondependent base
public:
    T strange; // T is Base<double>::T, not the template parameter!
};
```

Dependent Base Classes
- a nondependent name appearing in a template is looked up as soon as it is encountered
- nondependent names are not looked up in dependent base classes
- dependent names can be looked up only at the time of instantiation
```cpp
template<typename T>
class DD1 : public Base<T> {
public:
    void f() { this->basefield = 0; } // lookup delayed
};

// An alternative consists in introducing a dependency using a qualified name
void f() { Base<T>::basefield = 0; }
```
- To avoid subtlety, we prefer to use the `this->` prefix in all situations that allow it—even for nontemplate code.

## Instantiation

### On-Demand Instantiation

When a C++ compiler encounters the use of a template specialization, it will create that specialization by substituting the required arguments for the template parameters. This is done automatically and requires no direction from the client code.

### Lazy Instantiation

Partial and Full Instantiation
- if an instance of a class template is referred to without the need for that instance to be a complete type, the compiler should not perform a complete instantiation of that class template instance.

Instantiated Components
- When a class template is implicitly (fully) instantiated, each declaration of its members is instantiated as well, but the corresponding definitions are not (i.e., the member are partially instantiated).

### The C++ Instantiation Model

Two-Phase Lookup
- parsing a template
    - nondependent names: ordinary lookup + ADL
    - dependent unqualified names: ordinary lookup (used to decide whether the name is a template)
- instantiating a template
    - dependent qualified names: ordinary lookup + ADL
    - dependent unqualified names: additional ADL

POI(Points of Instantiation)
- the POI for a reference to a function template specialization to be immediately after the nearest namespace scope declaration or definition that contains that reference.
- variable templates is handled similarly to that of function templates.
- the POI for a reference to a generated class instance is defined to be the point immediately before the nearest namespace scope declaration or definition that contains the reference.

The Inclusion Model
- place all their template definitions in header files
- Implementation Schemes
    - Greedy Instantiation
    - Queried Instantiation
    - Iterated Instantiation

### manage instantiations

Manual Instantiation：manually instantiating those template specializations that the program requires in a single location

Explicit Instantiation Declarations:
- explicit instantiation directive prefixed by the keyword `extern`
- **generally** suppresses automatic instantiation of the named template specialization

### Compile-Time if Statements

the discarded branch is not instantiated

## Template Argument Deduction

### The Deduction Process

basis
- Each argument-parameter pair is analyzed independently, 
- and if the conclusions differ in the end, the deduction process fails.

argument-parameter matching
- If the call parameter is declared with a reference declarator:
    - P is taken to be the type referenced, 
    - and A is the type of the argument. 
- Otherwise, however:
    - P is the declared parameter type, 
    - and A is obtained from the type of the argument by decaying array and function types to pointer types, ignoring top-level const and volatile qualifiers.

### Deduced Contexts

most type declaration constructs can be matched in this way, and these are called deduced contexts. 
However, a few constructs are not deduced contexts:
- `X<N>::I`
- `int(&)[sizeof(S<T>)]`

### Special Deduction Situations

- when the address of a function template is taken

### Initializer Lists

```cpp
#include <initializer_list>
template<typename T> void f(T p);
int main() {
    f({1, 2, 3}); // ERROR: cannot deduce T from a braced list
}

template<typename T> void f(std::initializer_list<T>);
int main()
{
    f({2, 3, 5, 7, 9}); // OK: T is deduced to int
    f({'a', 'e', 'i', 'o', 'u', 42}); // ERROR: T deduced to both char and int
}
```

### Parameter Packs

- the same parameter pack (P) is matched to multiple arguments (A)
- Literal Operator Templates
```cpp
template<char...> int operator "" _B7();
```

### Rvalue References

Reference Collapsing Rules
- any `const` or `volatile` qualifiers applied on top of the inner reference are simply discarded
- if either reference is an lvalue reference, so is the resulting type; otherwise, it is an rvalue reference

Forwarding References
- template argument deduction considers not just the type of the function call argument but also whether that argument is an lvalue or an rvalue
```cpp
template<typename T> void f(T&& p); // p is a forwarding reference
void g()
{
    int i;
    int const j = 0;
    f(i); // argument is an lvalue; deduces T to int&, and parameter type int&
    f(j); // argument is an lvalue; deduces T to int const&, and parameter type int const&
    f(2); // argument is an rvalue; deduces T to int, parameter type int&&
}

// the std::remove_reference type trait is frequently used to ensure that x is not a reference
template<typename T> void f(T&&) // p is a forwarding reference
{
    std::remove_reference_t<T> x; // x is never a reference
}
```

Perfect Forwarding
- basis
```cpp
#include <utility>
template<typename T> void forwardToG(T&& x)
{
    g(std::forward<T>(x)); // forward x to g()
}

template<typename... Ts> void forwardToG(Ts&&... xs)
{
    g(std::forward<Ts>(xs)...); // forward all xs to g()
}
```
- this deduction rule does not apply in any of the following situations:
```cpp
template<typename T>
class X
{
public:
    X(X&&); // X is not a template parameter
    X(T&&); // this constructor is not a function template
    template<typename Other> X(X<U>&&); // X<U> is not a template parameter
    template<typename U> X(U, T&&); // T is a template parameter from an outer template
};
```

forwarding the return value of a call to another function
- The use of `decltype(auto)` as a return type indicates that the compiler should deduce the return type from the definition of the function.
- avoiding deduced return types if they can easily be specified explicitly
```cpp
template<typename... Ts>
decltype(auto) forwardToG(Ts&&... xs)
{
    return g(std::forward<Ts>(xs)...); // forward all xs to g()
}
```

### SFINAE

SFINAE protects against attempts to form invalid types or expressions, including errors due to ambiguities or access control violations, that occur within the **immediate context** of the function template substitution

what is not in that context
- the definition of a class template (i.e., its “body” and list of base classes)
- the definition of a function template
- ...

an error during that instantiation is not in the immediate context of the function template substitution and is therefore a real error

### Limitations of Deduction

Allowable Argument Conversions （The relaxed matching requirements are considered only if an exact match was not possible）
- when P contains a template parameter in a deduced context
    - may be more const/volatile-qualified
    - may be a base class type
- when P does not contain a template parameter in a deduced context
    - all implicit conversion are permissible

Default Call Arguments
- it cannot be used to deduce template arguments

Exception Specifications
- only instantiated when they are needed. This means that they do not participate in template argument deduction.

## Explicit Function Template Arguments

It is possible to explicitly specify some template arguments while having others be deduced.

## Deduction from Initializers and Expressions

### The auto Type Specifier

The `auto` type specifier can be used:
- deduce the type of a variable from its initializer.
    - forwarding reference
    - can combine the auto specifier to make a variable const, a pointer, a member pointer, and so on
- Deduced Return Types
    - It is therefore important to remember that deduced return types are not merely a shorthand for a complex explicit return type and they should be used with care (i.e., with the understanding that they shouldn’t be called in the signatures of other function templates that would count on SFINAE properties)
```cpp
auto f() { return 42; }

auto lm = [] (int x) { return f(x); }; // same as: [] (int x) -> auto { return f(x); };
```
- Deducible Nontype Parameters
```cpp
template<auto V> struct Value {
    using ArgType = decltype(V);
};
```

### Expressing the Type of an Expression with `decltype`

If `e` is the name of an entity or a class member access:
- `decltype(e)` yields the declared type of that entity or the denoted class member

if `e` is any other expression:
- `decltype(e)` produces a type that reflects the type and value category of that expression as follows:
    - If `e` is an lvalue of type `T`, `decltype(e)` produces `T&`.
    – If `e` is an xvalue of type `T`, `decltype(e)` produces `T&&`.
    – If `e` is a prvalue of type `T`, `decltype(e)` produces `T`.
```cpp
void g (std::string&& s)
{
    std::is_rvalue_reference<decltype(s)>::value; // true (s as declared)
    // check the value category of s used as expression:
    std::is_lvalue_reference<decltype((s))>::value; // true (s is an lvalue)
}
```

### `decltype(auto)`

the actual type is determined by applying the `decltype` construct directly to the expression
```cpp
int i = 42; // i has type int
int const& ref = i; // ref has type int const& and refers to i
auto x = ref; // x1 has type int and is a new independent object
decltype(auto) y = ref; // y has type int const& and also refers to i
```

`decltype(auto)` does not allow specifiers or declarator operators that modify its type
```cpp
decltype(auto)* p = (void*)nullptr; // invalid
```

parentheses in the initializer may be significant
```cpp
int x;
decltype(auto) z = x; // object of type int
decltype(auto) r = (x); // reference of type int&
```

can also be used for deducible nontype parameters
```cpp
template<decltype(auto) Val> class S {};
```

### Special Situations for auto Deduction

- initializer_list
```cpp
template<typename T>
void deduceInitList(std::initializer_list<T>);
deduceInitList({ 2, 3, 5, 7 }); // OK: T deduced as int

auto primes = { 2, 3, 5, 7 }; // primes is std::initializer_list<int>
auto oops { 0, 8, 15 }; // ERROR in C++17
auto val { 2 }; // OK: val has type int in C++17
auto subtleError() {
    return { 1, 2, 3 }; // ERROR
}
```

- multiple variable declarations share the same `auto`
    - deduction is performed independently for each declaration
    - the deductions for T1 and T2 are the same type, are the declarations well-formed
```cpp
auto first = container.begin(), last = container.end();
```

- `auto` return type with multiple `return`
    - each return statement is deduced independently
    - If the returned expression calls the function recursively, deduction cannot occur and the program is invalid unless a prior deduction already determined the return type.
```cpp
auto f(bool b) {
    if (b) {
        return 42.0; // deduces return type double
    } else {
        return 0; // ERROR: deduction conflict
    }
}

auto f(int n)
{
    if (n > 1) {
        return n*f(n-1); // ERROR: type of f(n-1) unknown
    } else {
        return 1;
    }
}

auto f1() { } // OK: return type is void
auto f2() { return; } // OK: return type is void
```

### Structured Bindings

a structured binding must:
- always have an auto type
- optionally extended by 
    - const and/or volatile qualifiers 
    - and/or &and/or && declarator operators
    - but not a * pointer declarator or some other declarator construct

Three different kinds of entities can initialize a structured binding: 
- simple class type, where all the nonstatic data members are public
    - no anonymous unions may be involved
- arrays
- `std::tuple`-like classes
    - `std::tuple`, `std::pair`, and `std::array`

### Generic Lambdas

For a generic lambda, the function call operator becomes a member function template.
```cpp
[] (auto i) {
    return i < 0;
}
```

### Alias Templates

Alias templates are “transparent” with respect to deduction: They can be used to clarify and simplify code but have no effect on how deduction operates.

## Class Template Argument Deduction

Deducing the template parameters of a class type from:
- the arguments specified in an initializer of a variable declaration 
- or a functional-notation type conversion

Note that:
all parameters must be determined by the deduction process or from default arguments. 
It is not possible to explicitly specify a few arguments and deduce others.

### Deduction Guides

treating the deduction guides associated with class S as an overload set and attempting overload resolution with the initializer against that overload set.

```cpp
template<typename T> S(T) -> S<T>; // deduction guide
```

### Implicit Deduction Guides

introducing for every constructor and constructor template of the primary class template an implicit deduction guide.

special case:
- multiple elements vs one-element
```cpp
std::vector v{1, 2, 3}; // vector<int>, not surprising
std::vector w2{v, v}; // vector<vector<int>>
std::vector w1{v}; // vector<int>!
```
- Injected Class Names
- Forwarding References
- The explicit Keyword
- Copy Construction and Initializer Lists
- Guides Are for Deduction Only

## Specialization and Overloading

### Overloading Function Templates

Two functions can coexist in a program if they have distinct signatures. We define the signature of a function:
- name of the function
- class or namespace scope
- qualification (for member function)
- The types of the function parameters
- Its return type (for template function)
- The template parameters and the template arguments (for template function)

Partial Ordering of Overloaded Function Templates
- whether one function template participating in an overload set is more specialized than the other
- if neither can be considered more specialized than the other, the program contains an ambiguity error

Templates and Nontemplates
- All else being equal, the non-template function is preferred
- when const and reference qualifiers differ, priorities for overload resolution can change
- usually you have to partially disable member function templates when they might hide copy or move constructors

Variadic Function Templates
- Variadic function templates require some special treatment during partial ordering, because deduction for a parameter pack matches a single parameter to multiple arguments

### Explicit Specialization

basis
- class templates and variable templates cannot be overloaded. Instead, Explicit Specialization was chosen to enable transparent customization of class templates.
- explicit specialization refers to a language feature that we call full specialization.
- Neither full nor partial specialization introduces a totally new template or template instance. Instead, these constructs provide alternative definitions for instances that are already implicitly declared in the generic (or unspecialized) template. This is a relatively important conceptual observation, and it is a key difference with overloaded templates.

Full Class Template Specialization
- The list of specified template arguments must correspond to the list of template parameters
- the members of a full class template specialization can be defined using the ordinary out-of-class member definition syntax
    - in other words, the `template<>` prefix cannot be specified
- it is not valid to have both the explicit and the generated versions of a template present in the same program
    - In practical terms, a declaration of the specialization should normally follow the declaration of the template in its header file
    - in general, it is better to avoid specializing templates coming from an external source unless it is clearly marked as being designed for that purpose.

Full Function Template Specialization
- overloading and argument deduction come into play
- cannot include default argument values
- typically be organized in two files
    - The interface file contains the definitions of primary templates and partial specializations but declares only the full specializations
    - The corresponding implementation file defines the full specialization

Full Variable Template Specialization

Full Member Specialization
- requires `template<>` prefix for every enclosing class template

### Partial Class Template Specialization

basis:
- matching full specializations are preferred over partial specializations
- There exist several limitations on the parameter and argument lists of partial specialization declarations

When a template is used, the primary template is always the one that is looked up, but then the arguments are also matched against those
of the associated specializations:
- If no matching specializations is found, the primary template is selected. 
- If multiple matching specializations are found, the most specialized one (in the sense defined for overloaded function templates) is
selected;
- if none can be called most specialized, the program contains an ambiguity error

it is entirely possible for a class template partial specialization to have more or fewer parameters than the primary template.

### Partial Variable Template Specialization

The rules regarding variable template partial specialization are similar to those for class template specializations.

## Future direction

- Relaxed typename Rules
- Generalized Nontype Template Parameters
- Partial Specialization of Function Templates
- Named Template Arguments
- Overloaded Class Templates
- Deduction for Nonfinal Pack Expansions
- Regularization of void
- Type Checking for Templates
- Reflective Metaprogramming
- Pack Facilities
- Modules