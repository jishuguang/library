# 模板

## Thes Basics

### Function Templates

Example: max

Two phase translation
- definition time
- instantiation time

Template argument deduction
- conversion：automatic type conversions are limited，only trivial conversions that decay are supported
- default argument deduction: need default arg for both template para and call para

Multi template paras
- determine return type:
    - template parameters for return types
    - (preference) deducing the return type with `auto`
    - return type as common type: `std::common_type`

Default template arguments
- may refer to previous template parameters
- it is possible to have default arguments followed by parameters not having default arguments.

Function template overloading
- template function vs normal function
- template function vs template function
- limit your changes in one aspect: the number of parameters or specifying template parameters explicitly
- you should ensure that only one of them matches for any call
- esure the compiler sees all overloaded versions of function templates before you call them

Basic question
- Pass by Value or by Reference：
    - passing by reference is only recommended for types other than cheap simple types
    - you can often still decide to pass arguments by reference, using `std::ref()` and `std::cref()`
    - unless some functionality is only possible when using references
- you can use `constexpr` to provide the ability to use code to compute some values at compile time
- only full specializations of templates for specific types need to be inline

### Class Templates

Example: stack

Declare class templates
- inside a class template using the class name not followed by template arguments represents the class with its template parameters as its arguments
- templates can only be defined in global/namespace scope or inside class declarations

Use of class template
- code is instantiated only for template (member) functions that are called

friend function
- implemented as nonmember function
- declare and define
    - implicitly declare a new function template (must use a different template parameter)
    - forward declare the output operator for a `Stack<T>` to be a template

Specializations of class templates
- similar to the overloading of function templates
- can be partially specialized

Default Class Template Arguments

Type Aliases
- define a new name for an existing type rather than a new type.
- alias template
    - example: Type Traits Suffix_t

Class Template Argument Deduction
- deduced from constructors
- unlike for function templates, class template arguments may not be deduced only partially
- Class Template Arguments Deduction with String Literals
    - passing arguments of a template type T by reference, the parameter doesn’t decay
    - passing arguments of a template type T by value, the parameter decays
    - For this reason, it might be worthwhile to declare the constructor so that the argument is passed by value
- Deduction Guides
    - can’t copy initialize (initialize using =) an object by passing a string literal to a constructor expecting a `std::string`
    - if in doubt, class template argument deduction copies (instead of initializing a stack by elements that are stacks)

### Nontype Template Parameters

Template Parameter Type `auto`
- accept any type that is allowed for a nontype parameter
```c++
template<decltype(auto) N>
class C {};

int i;
C<(i)> x; // N is int&
```


Mix type and nontype template paras
```c++
template<auto Val, typename T = decltype(Val)>

template<typename T, T Val = T{}>
```

Restriction
- can be only:
    - constant integral values (including enumerations)
    - pointers to objects/functions/members
    - lvalue references to objects or functions
    - or std::nullptr_t
- can not be:
    - Floating-point numbers
    - class-type objects
- the passing objects must not be string literals, temporaries, or data members and other subobjects without restrictions
- Arguments for nontype template parameters might be any compile-time expressions

### Variadic Templates

Basics
- template parameter pack
- function parameter pack
- `sizeof...`
- fold expression
```c++
(... op pack)
(pack op ...)
(init op ... op pack)
(pack op ... op init)
```

Overloading Variadic and Nonvariadic Templates
- function template without the trailing parameter pack is preferred

Application of Variadic Templates
- variadic expression
- variadic indices
- variadic class templates
- variadic deduction guides
- variadic base classes
```c++
template<typename… Bases>
struct Overloader : Bases…
{
using Bases::operator()…;
};
```

### Tricky basics

`typename` keyword
- clarify that an identifier inside a template is a type
- used whenever a name that depends on a template parameter is a type

zero initialization
```c++
T x{};
void foo(T p = T{});
```

base clase template
- qualify any symbol that is declared in a base class template with `this->` or `Base<T>::`

Templates for Raw Arrays and String Literals
- provide templates that specifically deal with raw arrays or string literals.

Member templates
- need use another type `T2`
- Specialization of Member Function Templates
- Special Member Function Templates
    - template constructors or template assignment operators don’t replace predefined constructors or assignment operators
    - It can happen that a template constructor or assignment operator is a better match than the predefined copy/move constructor or assignment operator
- `.template, ->template, ::template` keyword: used only inside templates and only if they follow something that depends on a template parameter
- generic lambdas are shortcuts for member templates

Variable templates
- variable templates are used in different translation units
- Variable Templates for Data Members: 
    - `template<typename T> constexpr bool isSigned = std::numeric_limits<T>::is_signed`
    - Type Traits Suffix _v

Template Template Parameters
- example: `template<typename T, template<typename Elem> typename Cont = std::deque>`
    - the template parameter of the template template parameter is not used, it is customary to omit its name
- we can also substitute template template parameter with the name of an alias template
- Template Template Argument Matching
    - prior to C++17: need exactly match the parameters of the template template parameter it substitutes

### Move Semantics in template

Perfect forwarding
- `T&&` forwarding reference

### enable_if

Disable Templates with `enable_if<>`/`enable_if_t`
- SFINAE: substitution failure is not an error
- the common way to use `std::enable_if<>` is to use an additional function template argument with a default value
```c++
template<typename T,
typename = std::enable_if_t<(sizeof(T) > 4)>>
void foo() {
}
```

Use of `enable_if`
- Special Member Function Templates
    - using `std::enable_if<>` to disable the member template when confilt with predefined special member function