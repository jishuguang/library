# 表达式

```{mermaid}
mindmap
Expressions
    Value categories
    Operator
    Const expression
    Conversions
    Literal
```

## 基础

Every expression has:
- a static type
- a value category

## Value categories

The core categories:
- lvalue: a glvalue that is not an xvalue. e.g.
    - Expressions that designate variables or functions
    - Applications of the built-in unary * operator (“pointer indirection”)
    - An expression that is just a string literal
    - A call to a function with a return type that is an lvalue reference
- prvalue (“pure rvalue”): an expression whose evaluation initializes an object or a bit-field, or computes the value of the operand of an operator. e.g.
    - Expressions that consist of a literal that is not a string literal or a user-defined literal
    - Applications of the built-in unary & operator
    - Applications of built-in arithmetic operators
    - A call to a function with a return type that is not a reference type
    - Lambda expressions
- xvalue: a glvalue designating an object or bit-field whose resources can be reused. e.g.
    - A call to a function with a return type that is an rvalue reference to an object type
    - A cast to an rvalue reference to an object type

The composite categories:
- glvalue (“generalized lvalue,” which is the union of lvalue and xvalue): an expression whose evaluation determines the identity of an object, bit-field, or function (i.e., an entity that has storage)
- rvalue (the union of xvalue and prvalue)

### Lvalue-to-Rvalue Conversions

```cpp
int x = 3;
int y = x; // x here is an lvalue. The evaluation of that lvalue expression does not
// produce the value 3, but a designation of an object containing the value 3.
// That lvalue is then then converted to a prvalue, which is what initializes y.
```

### Temporary Materialization

It could just as well have been called “prvalue-to-xvalue conversion”: Any time a prvalue validly appears where a glvalue (which includes the xvalue case) is expected, a temporary object is created and
initialized with the prvalue (recall that prvalues are primarily “initializing values”), and the prvalue is replaced by an xvalue designating the temporary.

A temporary is materialized to be initialized with a prvalue in the following situations:
- A prvalue is bound to a reference
- A member of a class prvalue is accessed
- ......

Example:

```cpp
class X {};
X v;
X const c;

void f(X const&); // accepts an expression of any value category
void f(X&&); // accepts prvalues and xvalues only but is a better match

// for those than the previous declaration
f(v); // passes a modifiable lvalue to the first
f(c); // passes a nonmodifiable lvalue to the first f()
f(X()); // passes a prvalue (since C++17 materialized as xvalue) to the 2nd f()
f(std::move(v)); // passes an xvalue to the second f()
```

### Check value category

`decltype((x))` yields:
- `type` if x is a prvalue
- `type&` if x is an lvalue
- `type&&` if x is an xvalue

`decltype(x)` yields (x simply names a variable v):
- produces the type of the variable v rather than a type reflecting the value category of the expression x referring to that variable.

### Reference type and value category

A reference may limit the value category of an expression it can bind to:
- non-const lvalue reference of type (e.g. `int&`): can only be initialized with an expression that is an lvalue of type int.
- an rvalue reference of type (e.g. `int&&`): can only be initialized with an expression that is an rvalue of type int.

The use of a reference type as the return type affects the value category of a call to that function:
- A call to a function whose return type is an lvalue reference yields an lvalue.
- A call to a function whose return type is an rvalue reference to an object type yields an xvalue (rvalue references to function types always result in lvalues).
- A call to a function that returns a nonreference type yields a prvalue.