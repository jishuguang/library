# 模板基础

## Function Templates

Example: max

Two phase translation
- definition time
- instantiation time

Template argument deduction
- conversion：automatic type conversions are limited，only trivial conversions that decay are supported
- default argument deduction: need default arg for both template para and call para

Multi template paras
- determine return type:
    - template parameters for return types
    - (preference) deducing the return type with `auto`
    - return type as common type: `std::common_type`

Default template arguments
- may refer to previous template parameters
- it is possible to have default arguments followed by parameters not having default arguments.

Function template overloading
- template function vs normal function
- template function vs template function
- limit your changes in one aspect: the number of parameters or specifying template parameters explicitly
- you should ensure that only one of them matches for any call
- esure the compiler sees all overloaded versions of function templates before you call them

Basic question
- Pass by Value or by Reference：
    - passing by reference is only recommended for types other than cheap simple types
    - you can often still decide to pass arguments by reference, using `std::ref()` and `std::cref()`
    - unless some functionality is only possible when using references
- you can use `constexpr` to provide the ability to use code to compute some values at compile time
- only full specializations of templates for specific types need to be inline

## Class Templates

Example: stack

Declare class templates
- inside a class template using the class name not followed by template arguments represents the class with its template parameters as its arguments
- templates can only be defined in global/namespace scope or inside class declarations

Use of class template
- code is instantiated only for template (member) functions that are called

friend function
- implemented as nonmember function
- declare and define
    - implicitly declare a new function template (must use a different template parameter)
    - forward declare the output operator for a `Stack<T>` to be a template

Specializations of class templates
- similar to the overloading of function templates
- can be partially specialized

Default Class Template Arguments

Type Aliases
- define a new name for an existing type rather than a new type.
- alias template
    - example: Type Traits Suffix_t

Class Template Argument Deduction
- deduced from constructors
- unlike for function templates, class template arguments may not be deduced only partially
- Class Template Arguments Deduction with String Literals
    - passing arguments of a template type T by reference, the parameter doesn’t decay
    - passing arguments of a template type T by value, the parameter decays
    - For this reason, it might be worthwhile to declare the constructor so that the argument is passed by value
- Deduction Guides
    - can’t copy initialize (initialize using =) an object by passing a string literal to a constructor expecting a `std::string`
    - if in doubt, class template argument deduction copies (instead of initializing a stack by elements that are stacks)

## Nontype Template Parameters

Template Parameter Type `auto`
- accept any type that is allowed for a nontype parameter
```c++
template<decltype(auto) N>
class C {};

int i;
C<(i)> x; // N is int&
```


Mix type and nontype template paras
```c++
template<auto Val, typename T = decltype(Val)>

template<typename T, T Val = T{}>
```

Restriction
- can be only:
    - constant integral values (including enumerations)
    - pointers to objects/functions/members
    - lvalue references to objects or functions
    - or std::nullptr_t
- can not be:
    - Floating-point numbers
    - class-type objects
- the passing objects must not be string literals, temporaries, or data members and other subobjects without restrictions
- Arguments for nontype template parameters might be any compile-time expressions

## Variadic Templates

Basics
- template parameter pack
- function parameter pack
- `sizeof...`
- fold expression
```c++
(... op pack)
(pack op ...)
(init op ... op pack)
(pack op ... op init)
```

Overloading Variadic and Nonvariadic Templates
- function template without the trailing parameter pack is preferred

Application of Variadic Templates
- variadic expression
- variadic indices
- variadic class templates
- variadic deduction guides
- variadic base classes
```c++
template<typename… Bases>
struct Overloader : Bases…
{
using Bases::operator()…;
};
```

## Tricky basics

`typename` keyword
- clarify that an identifier inside a template is a type
- used whenever a name that depends on a template parameter is a type

zero initialization
```c++
T x{};
void foo(T p = T{});
```

base clase template
- qualify any symbol that is declared in a base class template with `this->` or `Base<T>::`

Templates for Raw Arrays and String Literals
- provide templates that specifically deal with raw arrays or string literals.

Member templates
- need use another type `T2`
- Specialization of Member Function Templates
- Special Member Function Templates
    - template constructors or template assignment operators don’t replace predefined constructors or assignment operators
    - It can happen that a template constructor or assignment operator is a better match than the predefined copy/move constructor or assignment operator
    - member function templates never count as special member functions and are ignored when, for example, a copy constructor is needed
- `.template, ->template, ::template` keyword: used only inside templates and only if they follow something that depends on a template parameter
- generic lambdas are shortcuts for member templates

Variable templates
- variable templates are used in different translation units
- Variable Templates for Data Members: 
    - `template<typename T> constexpr bool isSigned = std::numeric_limits<T>::is_signed`
    - Type Traits Suffix _v

Template Template Parameters
- example: `template<typename T, template<typename Elem> typename Cont = std::deque>`
    - the template parameter of the template template parameter is not used, it is customary to omit its name
- we can also substitute template template parameter with the name of an alias template
- Template Template Argument Matching
    - prior to C++17: need exactly match the parameters of the template template parameter it substitutes

## Move Semantics in template

Perfect forwarding
- `T&&` forwarding reference

## enable_if

Disable Templates with `enable_if<>`/`enable_if_t`
- SFINAE: substitution failure is not an error
- the common way to use `std::enable_if<>` is to use an additional function template argument with a default value
```c++
template<typename T,
typename = std::enable_if_t<(sizeof(T) > 4)>>
void foo() {
}
```

Use of `enable_if`
- Special Member Function Templates
    - using `std::enable_if<>` to disable the member template when confilt with predefined special member function
- Disabling Special Member Functions
```c++
template<typename T>
class C
{
public:
// user-define the predefined copy constructor as deleted
// (with conversion to volatile to enable better matches)
C(C const volatile&) = delete;
// if T is no integral type, provide copy constructor template with better match:
template<typename U,
typename = std::enable_if_t<!std::is_integral<U>::value>>
C (C<U> const&) {/*...*/}
};
```

## concepts

Using Concepts to Simplify `enable_if`
```c++
template<typename STR>
requires std::is_convertible_v<STR,std::string>

// general concept
template<typename T>
concept ConvertibleToString = std::is_convertible_v<T,std::string>;
template<typename STR>
requires ConvertibleToString<STR>
// or
template<ConvertibleToString STR>
```

## By value or by reference

### By value

various way to avoid expensive copying even when passing parameters by value
```c++
std::string returnString();
std::string s = "hi";
printV(s); //copy constructor
printV(std::string("hi")); //copying usually optimized away (if not, move constructor)
printV(returnString()); // copying usually optimized away (if not, move constructor)
printV(std::move(s)); // move constructor
```

Passing by Value Decays
- raw arrays get converted to pointers 
- qualifiers such as const and volatile are removed
- ......

### By reference

passing the argument never decays

reasons for use reference:
- Copying is not possible.
- Parameters are used to return data.
- Templates just forward the parameters to somewhere else by keeping all the properties of the original arguments.
- There are significant performance improvements

different ways:
- `T const&`
    - the template parameter `T` itself is not deduced as `const`
- `T&`
    - If you pass a const argument, the deduction might result in arg becoming a declaration of a constant reference
    - If you want to disable passing constant objects to nonconstant references, use `enable_if` or `concept` or `static_assert`
- `T&&`
    - this is the only case where the template parameter T implicitly can become a reference type.

problem when by refence
- passing an argument by reference is implemented by passing the address of the argument. 
- passing an address can create uncertainties for the compiler
- can be moderated by inlining

### std::ref

the compiler has to know that an implicit conversion back to the original type.
```c++
// fail because there is no output operator defined for std::reference_wrapper<>
template<typename T>
void printV (T arg) {
    std::cout << arg << ’\n’;
}
```

### Dealing with String Literals and Raw Arrays

- You can declare template parameters so that they are only valid for arrays
- You can use type traits to detect whether an array (or a pointer) was passed
- Due to these special handling, often the best way to deal with arrays in different ways is simply to use different function names

### Dealing with Return Values

Ensure that return values are usually passed by value, while using a template parameter T is no guarantee that it is not a reference

To be safe, you have two options
- `std::remove_reference<>`
- declaring the return type to be `auto`, because `auto`` always decays

### Recommended Template Parameter Declarations

General Recommendations
- By default, declare parameters to be passed by value
- If there are good reasons, do otherwise:
    - out or inout param
    - forward argument
    - performance
- If you know better, don’t follow these recommendations
- Don’t Be Over-Generic

## Compile-time programming

- Template Metaprogramming
    - C++ templates can be combined with the instantiation process to produce a sort of primitive recursive “programming language” within the C++ language itself.
- Computing with constexpr
- Execution Path Selection with Partial Specialization (only for class)
    - select among different implementations of a function template depending on properties of the arguments it’s being invoked for
- SFINAE and Overload Resolution
    - Expression SFINAE with decltype
    ```c++
    template<typename T>
    auto len (T const& t) -> decltype( (void)(t.size()), T::size_type() )
    { return t.size(); }
    ```
- Compile-Time if: `if constexpr()`
    - if the code is not instantiated, then only the first translation phase (the definition time) is performed
    - can be used outside templates

## Use templates in practice

### The inclusion model

inclusion model
- include the definitions of a template in the header file that declares that template

build-time issue: include the headers used by the definition of templates
- precompiled headers (PCH)
- use of explicit template instantiation
- modules

### Template and inline

full specializations of function templates can appear only once unless they’re defined `inline`

## Basic Template Terminology

- class tempalte vs template class
- Substitution, Instantiation, and Specialization
- Template Arguments versus Template Parameters

## Generic Libraries

### Callables

function object types (can be directly called with the syntax `f(… )`)
- Pointer-to-function types
- Class types with an overloaded `operator()` (sometimes called functors)
- Lambda expressions produce functors (called closures)
- Class types with a conversion function yielding a pointerto-function or reference-to-function

callable type, which is:
- either a function object type
- or a pointer to member

`std::invoke`:
- unifies ordinary function-call and member functions
- Wrapping Function Calls
    - `decltype(auto)`: to support returning references

### Other utilities

Type traits
- the order of removing references and const matters: `std::remove_const_t<std::remove_reference_t<int const&>>`
- value category matters: `is_assignable_v<int,int>` vs `is_copy_assignable_v<int>`

`std::addressof()`: works even if the object type has an overloaded operator `&`
`std::declval()`: a placeholder for an object reference of a specific type

### Perfect Forwarding Temporaries

```cpp
auto&& val = get(x);
// perfectly forward the return value of get() to set():
set(std::forward<decltype(val)>(val));
```

### References as Template Parameters

Reference types in general are quite unlike other types and are subject to several unique language rules.

### Defer Evaluations

template can deal with incomplete types

```cpp
template<typename T>
class Cont {
private:
T* elems;

public:
template<typename D = T>
typename std::conditional<std::is_move_constructible<D>::value, T&&, T&>::type foo();
};
```

### things to remember when implementing generic libraries

- Use forwarding references to forward values in templates
    - be prepared that a template parameter has a reference type when passing lvalues
- Use `std::addressof()`
- For member function templates, ensure that they don’t match better than the predefined copy/move constructor or assignment operator
- using `std::decay` when template parameters might be string literals
- Be prepared to deal with the side effects of template parameters being references
- Be prepared to deal with incomplete types to support