# 对象模型

```{mermaid}
mindmap
C++对象模型
    Basic model
    Data member
    Member function
        Constructor
        Destructor
        Virtual function
    Runtime
        Object construction/destruction
        operator new/delete
        Temporaries
        RTTI
        Exception handle
```

## Basic model

C++ Object Model:
- Nonstatic data members are allocated directly within each class object. 
- Static data members are stored outside the individual class object.
- Static and nonstatic function members are also hoisted outside the class object.
- Virtual functions are supported in two steps: 
    - A table of pointers to virtual functions is generated for each class (this is called the virtual table). 
    - A single pointer to the associated virtual table is inserted within each class object (`vptr`). The setting, resetting, and not setting of the vptr is handled automatically through code generated within each class constructor, destructor, and copy assignment operator.

## Data member

### Inheritance and the data member

General implementation:
- In practice, the base class members always appear first, except in the case of a virtual base class.
- Adding polymorphism locate the `vptr` within the class object (at the start of the class or at the end)
- Multiple inheritance affects conversions between the derived and second or 
subsequent base class objects: requires that that address be modified by the 
addition (or subtraction in the case of a downcast) of the size of the intervening base class subobject.
```cpp
pv = &v3d; 
// requires a conversion of the form 
// Pseudo C++ Code 
pv = (Vertex*)(((char*)&v3d) + sizeof(Point3d));
```

- Virtual inheritance: A class containing one or more virtual base class subobjects is divided into two regions: 
    - an invariant region: Data within the invariant region remains at a fixed offset from the start of the object regardless of subsequent derivations, can be accessed directly
    - a shared region: represents the virtual base class subobjects. The location of data within the shared region fluctuates with each derivation. So members within the shared region need to be accessed indirectly. What has varied among implementations is the method of indirect access.
    - The general layout strategy is to first lay down the invariant region of the derived class and then build up the shared region.

How is the implementation to gain access to the shared region:
- place the offset of the virtual base class within the virtual function table.

```cpp
Vertex *pv = pv3d; 
// under this implementation model becomes
// Pseudo C++ code 
Vertex *pv = pv3d ? pv3d + pv3d->__vptr__Point3d[-1] : 0;
```

- MI:
    - Under multiple inheritance, a derived class contains n – 1 additional virtual tables 
    - The address of the new Derived object must be adjusted to address its Base2 subobject.

```cpp
// transformation to support second base class
// The code to accomplish this is generated at compile time 
Derived *temp = new Derived; 
Base2 *pbase2 = temp ? temp + sizeof(Base1) : 0;
```

### Pointer to Data Members

It needs to be bound to the address of a class object before an actual instance of the member can be accessed.

```cpp
float Point3d::*p2 = &3d_point::z; 
// It is going to yield the z-coordinate's offset within the class object.
```

## Member function

### Constructor

#### Default constructor

Nontrivial default constructors:
- Class with a Virtual Base Class: derived from an inheritance chain in which one or more base classes are virtual
    to make the virtual base class location within each derived class object available  at runtime
- Class with a Virtual Function: The class either declares (or inherits) a virtual function
- Base Class with Default Constructor
- Member Class Object with Default Constructor

Trivial default constructors are not synthesized.

#### Copy constructor

When are bitwise copy semantics not exhibited (same as for a copy operator):
- When the class is derived from an inheritance chain in which one or more base classes are virtual
- When the class declares one or more virtual functions
- When the class contains a member object of a class for which a copy constructor exists (either explicitly declared by the class designer or synthesized by the compiler)
- When the class is derived from a base class for which a copy constructor exists

### Destructor

If a destructor is not defined by a class, the compiler synthesizes one only if the class contains either a member or base class with a destructor. Otherwise, the destructor is considered to be trivial and is therefore neither synthesized nor invoked in practice (even though it contains a virtual function).

A user-defined destructor is augmented in much the same way as are the constructors, except in reverse order: 
- If the object contains a vptr, it is reset to the virtual table associated with the class. 
- The body of the destructor is then executed; that is, the vptr is reset prior to evaluating the usersupplied code. 
- If the class has member class objects with destructors, these are invoked in the reverse order of their declaration. 
- If there are any immediate nonvirtual base classes with destructors, these are invoked in the reverse order of their declaration. 
- If there are any virtual base classes with destructors and this class represents the most-derived class, these are invoked in the reverse order of their original construction.

```{note}
To determine if a class needs a program level destructor (or constructor, for that matter), consider the case where the lifetime of a class object terminates (or begins). What, if anything, needs to be done to guarantee that object's integrity? This is preferably what you need to program (or else the user of your class has to). This is what should go into the destructor (or constructor).
```

### Virtual function

Basis:
- Each virtual function is assigned a fixed index within the `vptr` table.
- Derived classes can introduce a new virtual function not present in the base class. So the virtual table is grown by a slot.

```cpp
ptr->normalize(); 
// would be internally transformed into 
(*ptr->vptr[1])(ptr);
```

Virtual Functions under MI: the thunk is a small assembly stub that
- adjusts the this pointer with the appropriate offset 
- and then jumps to the virtual function

```cpp
// the thunk associated with the call of the Derived class destructor through a Base2 pointer might look as follows
// Pseudo C++ code 
// pbase2_dtor_thunk: 
this -= sizeof( base1 ); 
Derived::~Derived( this );
```

Virtual Functions under Virtual Inheritance
- use thunk to adjust `this` pointer
- recommendation: not to declare nonstatic data members within a virtual base class.

Introduction of the virtual function causes the following compiler-driven augmentations to constructor:
- code added to constructor to initialize the virtual table pointer
- both a copy constructor and a copy operator need to be synthesized

Object Construction under Inheritance:
- The data members initialized in the member initialization list have to be entered within the body of the constructor in the order of member declaration. 
- If a member class object is not present in the member initialization list but has an associated default constructor, that default constructor must be invoked.
- Prior to that, if there is a virtual table pointer (or pointers) contained within the class object, it (they)  must be initialized with the address of the appropriate virtual table(s).
- Prior to that, all immediate base class constructors must be invoked in the order of base class 
declaration
- Prior to that, all virtual base class constructors must be invoked in a left-to-right, depth-first search of the inheritance hierarchy defined by the derived class
    - These constructors, however, may be invoked if, and only if, the class object represents the 
"most-derived class."

### Pointer-to-Member Functions

The value returned from taking the address of a nonstatic member function, if it is nonvirtual, is the actual address in memory where the text of the function is located. It needs to be bound to the address of a class object before an actual invocation of the member function is possible.

```cpp
double (Point::*coord)() = &Point::x;
```

Taking the address of a virtual member function yields its index into its class's associated virtual table.

## Runtime

### Object construction and destruction

Global Objects: ELF provides `.init` and `.fini` sections that contain information on the objects requiring, respectively, static initialization and deallocation. Implementation-specific startup routines (usually named something like `crt0.o`) complete the platform specific support for static initialization and deallocation.

Local Static Objects: have its constructor and destructor applied only once. A temporary may be introduced to guard its initialization and deallocation.

### Operators new and delete

`new T`:
- The allocation of the requested memory through invocation of the appropriate `operator new`
- The initialization of the allocated object (the initialization is performed only if the allocation of the object by `operator new` succeeds)

```cpp
Point3d *origin = new Point3d; 
// is transformed into 

// Pseudo C++ code
Point3d *origin; 
if (origin = __new( sizeof( Point3d ))) 
    origin = Point3d::Point3d( origin );
```

`delete <ptr>`: 
- first invoke the correct virtual instance of the destructor
- then apply `operator delete`.

```cpp
delete origin; 

// becomes 
if ( origin != 0 ) { 
    // Pseudo C++ code 
    Point3d::~Point3d( origin ); 
    __delete( origin ); 
}
```

`new T[N]`:

```cpp
Point3d *p_array = new Point3d[ 10 ]; 

// is generally transformed into 
Point3d *p_array; 
p_array = vec_new(0, sizeof( Point3d ), 10, &Point3d::Point3d, &Point3d::~Point3d);
```

`delete[] <ptr>`: The compiler searches for a dimension size only if the bracket is present.

placement-new:

```cpp
// example
p2w->~Point2w; 
p2w = new (arena) Point2w;
```

### Temporaries

Named Return Value (NRV) optimization:

```cpp
X bar()
{ 
    X xx; 
    // ... process xx 
    return xx; 
} 

// __result is substituted for xx by the compiler: 
void bar(X &__result) 
{ 
    // default constructor invocation 
    // Pseudo C++ Code 
    __result.X::X(); 
    // ... process in __result directly 
    return; 
}
```

```cpp
// generally implemented without the generation of a temporary
T c = a + b;
```

```cpp
// cannot safely eliminate the temporary
c = a + b;

// Pseudo C++ code 
// T temp = a + b; 
T temp; 
a.operator+(temp, b); // 1 
// c = temp 
c.operator =(temp); // 2 
temp.T::~T();


// there can be no guarantee that the following sequences result in the same semantics
c.T::~T(); 
c.T::T( a + b );
```

```cpp
String v; 
v = s + t + u; 
// or 
printf( "%s\n", s + t ); 

// results in a temporary being associated with the s + t subexpression.
```

The lifetime of temporaries rule:
- The temporaries must not be destroyed until after evaluation of the full expression
- excpetion
 - the temporary that holds the result of the expression shall persist until the object's initialization is complete.
 - when a temporary is bound to a reference

 ### Exception handle

 ```{note}
 TODO
 ```

### RTTI

The `dynamic_cast` of a class pointer type provides a true/false pair of alternative pathways during program execution.

The dynamic_cast operator, when applied to a reference, cannot provide an equivalent true/false pair of 
alternative pathways as it does with a pointer. If the reference is not actually a kind of the derived class, a `bad_cast` exception is thrown.

```cpp
pfct pf = dynamic_cast< pfct >( pt )

 // access of type descriptor for pt 
((type_info*) (pt->vptr[ 0 ]))->_type_descriptor;
```

The `typeid` operator returns a const reference of type `type_info`.