# 模板设计

## The Polymorphic Power of Templates

### Dynamic versus Static Polymorphism

Terminology
- Bounded means that the interfaces of the types participating in the polymorphic behavior are predetermined by the design of the common base class (other terms for this concept are invasive and intrusive)

basis difference:
- Polymorphism implemented via inheritance is bounded and dynamic (bounded dynamic polymorphism)
    - Heterogeneous collections are handled elegantly
    - The executable code size is potentially smaller
    - no implementation source must be published
- Polymorphism implemented via templates is unbounded and static (unboundedstatic polymorphism)
    - the interface commonality need not be expressed through a common base class
    - Generated code is potentially faster
    - Concrete types that provide only partial interfaces can still be used if only that part ends up being exercised by the application.
- In other languages, other combinations exist

Combining Both Forms
- curiously recurring template pattern (or CRTP)

### New Forms of Design Patterns

Bridge pattern
- dynamic: using an interface class that embeds a pointer to refer to the actual implementation and delegating all calls through this pointer
- static: impl template parameter

### Generic Programming

the most significant contribution in this area is the Standard Template Library (STL)

## Implementing Traits

Traits (or traits templates) are C++ programming devices that greatly facilitate the management of the sort of extra parameters that come up in the design of industrial-strength templates.

### Basic

type trait vs value trait
- additional type information related to a given “main” type
- Constants and other classes of values can be associated with a type

Parameterized Traits vs Fixed Trait
- adding a template parameter AT for the trait itself having a default value determined by our traits template

Traits versus Policies and Policy Classes
- Traits represent natural additional properties of a template parameter.
- Policies represent configurable behavior for generic functions and types
- 

Member Templates versus Template Template Parameters
- ordinary classes with a member template
- An alternative consists of designing the policy class interface using class templates, which are then used as template template arguments

Combining Multiple Policies and/or Traits
- order the parameters according to the increasing likelihood of their default value to be selected
- Typically, this would mean that the traits parameters follow the policy parameters

Type functions
- functions that takes some type as arguments and produce a type or a constant as a result.
- Build-in: `sizeof`

### SFINAE Based Trait

SFINAE Out Function Overloads
```cpp
template<typename T>
struct IsDefaultConstructibleHelper {
private:
// test() trying substitute call of a default constructor for T passed as U:
template<typename U, typename = decltype(U())>
static std::true_type test(void*);
// test() fallback:
template<typename>
static std::false_type test(...);
public:
using Type = decltype(test<T>(nullptr));
};
template<typename T>
struct IsDefaultConstructibleT : IsDefaultConstructibleHelper<T>::Type
{};
```

SFINAE Out Partial Specializations
```cpp
template<typename, typename = VoidT<>>
struct IsDefaultConstructibleT : std::false_type
{};

// partial specialization (may be SFINAE’d away):
template<typename T>
struct IsDefaultConstructibleT<T, VoidT<decltype(T())>> : std::true_type
{};
```

Using Generic Lambdas for SFINAE
```cpp
// usage example
constexpr auto hasFirst
= isValid([](auto x) -> decltype((void)valueT(x).first) {
});
```

SFINAE-Friendly Traits
- what: giving a suitable definition even when some expression is ill-formed.
- why: the program may fail to compile primary template even if we add a specific overload, because
C++ does not specify whether the types in a function template are actually instantiated if another overload would be better
```cpp
template<typename T1, typename T2, bool = HasPlusT<T1, T2>::value>
struct PlusResultT { //primary template, used when HasPlusT yields true
using Type = decltype(std::declval<T1>() + std::declval<T2>());
};

template<typename T1, typename T2>
struct PlusResultT<T1, T2, false> { //partial specialization, used otherwise
};
```

### Traits convenience

Alias Templates and Traits
- standard library: given a `_t` suffix
```cpp
// example
template<typename T>
using RemoveCV = typename RemoveCVT<T>::Type;
```

Variable Templates and Traits
- standard library: with a `_v` suffix
```cpp
// example
template<typename T1, typename T2>
constexpr bool IsSame = IsSameT<T1,T2>::value;
```

### Property Traits

Element type
- the standard containers contains member type `value_type`

Transformation traits (use partial specialization)
- `remove_reference`
- `add_lvalue_reference`, `add_rvalue_reference`
- `remove_volatile`, `remove_const`...
- `decay`

Predicate traits
- `true_type`, `false_type`
- `is_same` (use partial specialization)
- `is_convertible` (use partil specializationi and SFINAE)

Result type traits (use `decltype` and `declval`)
- PlusResultT
```cpp
// declval
// only meant to be used within decltype, sizeof, or some other context where no definition is ever needed.
template<typename T>
add_rvalue_reference_t<T> declval() noexcept;

template<typename T1, typename T2>
struct PlusResultT {
using Type = decltype(std::declval<T1>() + std::declval<T2>());
};
```

Detecting member (use SFINAE)
- member type: `template<typename T> struct HasSizeTypeT<T, VoidT<RemoveReference<T>::size_type>> : std::true_type {};`
- Arbitrary Member Types: achieved via SFINAE macros
- Nontype Members: `std::void_t<decltype(&T::Member)>`
    - The member must be accessible
- Member Functions: `std::void_t<decltype(std::declval<T>().begin())>`
- multiple expressions:
```cpp
std::void_t<decltype(std::declval<T>().begin()),
typename T::difference_type,
typename T::iterator>
```

Type classification (most use partial specialization)
- `is_integral`, `is_fundamental`
- `is_pointer`
- `is_reference`
- `is_array`
- `is_member_object_pointer`
- `is_function`
- `is_class` (use SFINAE)
- `is_union` (require special compiler support)
- `is_enum` (require special compiler support)

Other traits
- `conditional` (use partial specialization)
- Detecting Nonthrowing Operations:
```cpp
// primary template:
template<typename T, typename = std::void_t<>>
struct IsNothrowMoveConstructibleT : std::false_type
{
};

// partial specialization (may be SFINAE’d away):
template<typename T>
struct IsNothrowMoveConstructibleT
<T, std::void_t<decltype(T(std::declval<T>()))>>
: std::bool_constant<noexcept(T(std::declval<T>()))>
{
};
```

### Policy Traits

