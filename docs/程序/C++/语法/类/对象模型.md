# 对象模型

```{mermaid}
mindmap
C++对象模型
    Basic model
    Data member
    Member function
        Constructor
        Destructor
    Runtime
```

## Basic model

C++ Object Model:
- Nonstatic data members are allocated directly within each class object. 
- Static data members are stored outside the individual class object.
- Static and nonstatic function members are also hoisted outside the class object.
- Virtual functions are supported in two steps: 
    - A table of pointers to virtual functions is generated for each class (this is called the virtual table). 
    - A single pointer to the associated virtual table is inserted within each class object (`vptr`). The setting, resetting, and not setting of the vptr is handled automatically through code generated within each class constructor, destructor, and copy assignment operator.

## Data member

### Inheritance and the data member

General implementation:
- In practice, the base class members always appear first, except in the case of a virtual base class.
- Adding polymorphism locate the `vptr` within the class object (at the start of the class or at the end)
- Multiple inheritance affects conversions between the derived and second or 
subsequent base class objects: requires that that address be modified by the 
addition (or subtraction in the case of a downcast) of the size of the intervening base class subobject.
```cpp
pv = &v3d; 
// requires a conversion of the form 
// Pseudo C++ Code 
pv = (Vertex*)(((char*)&v3d) + sizeof(Point3d));
```

- Virtual inheritance: A class containing one or more virtual base class subobjects is divided into two regions: 
    - an invariant region: Data within the invariant region remains at a fixed offset from the start of the object regardless of subsequent derivations, can be accessed directly
    - a shared region: represents the virtual base class subobjects. The location of data within the shared region fluctuates with each derivation. So members within the shared region need to be accessed indirectly. What has varied among implementations is the method of indirect access.
    - The general layout strategy is to first lay down the invariant region of the derived class and then build up the shared region.

How is the implementation to gain access to the shared region:
- place the offset of the virtual base class within the virtual function table.

```cpp
Vertex *pv = pv3d; 
// under this implementation model becomes
// Pseudo C++ code 
Vertex *pv = pv3d ? pv3d + pv3d->__vptr__Point3d[-1] : 0;
```

### Pointer to Data Members



## Member function

### Constructor

#### Default constructor

Nontrivial default constructors:
- Class with a Virtual Base Class: derived from an inheritance chain in which one or more base classes are virtual
    to make the virtual base class location within each derived class object available  at runtime
- Class with a Virtual Function: The class either declares (or inherits) a virtual function
- Base Class with Default Constructor
- Member Class Object with Default Constructor

Trivial default constructors are not synthesized.

#### Copy constructor

When are bitwise copy semantics not exhibited:
- When the class is derived from an inheritance chain in which one or more base classes are virtual
- When the class declares one or more virtual functions
- When the class contains a member object of a class for which a copy constructor exists (either explicitly declared by the class designer or synthesized by the compiler)
- When the class is derived from a base class for which a copy constructor exists

Named Return Value (NRV) optimization:

```cpp
X bar()
{ 
    X xx; 
    // ... process xx 
    return xx; 
} 

// __result is substituted for xx by the compiler: 
void bar(X &__result) 
{ 
    // default constructor invocation 
    // Pseudo C++ Code 
    __result.X::X(); 
    // ... process in __result directly 
    return; 
}
```