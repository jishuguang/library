# 模板重载

```{mermaid}
mindmap
模板重载
    Partial ordering
    Tag dispatching
    SFINAE
    Compile-Time if
```

## 基础

C++ does not currently provide any direct way to express overloads based on type properties.

```cpp
// the names of template parameters are ignored when comparing two function templates
// the two f function templates are actually declarations of the same function template
template<typename Number> void f(Number); // only for numbers
template<typename Container> void f(Container);// only for containers
```

The design and optimization approach of introducing more specialized variants of a generic algorithm is called *algorithm specialization*.

## Partial ordering

```cpp
// generic algorithm
template<typename T>
void swap(T& x, T& y)
{
    T tmp(x);
    x = y;
    y = tmp;
}

// more specialized based on the partial ordering rules for function templates, so the compiler will pick this when it is applicable
template<typename T>
void swap(Array<T>& x, Array<T>& y)
{
    swap(x.ptr, y.ptr);
    swap(x.len, y.len);
}
```

## Tag Dispatching

Tag dispatching supports simple dispatching based on hierarchical tags.

```cpp
template<typename Iterator, typename Distance>
void advanceIter(Iterator& x, Distance n)
{
    advanceIterImpl(x, n, typename std::iterator_traits<Iterator>::iterator_category());
}

template<typename Iterator, typename Distance>
void advanceIterImpl(Iterator& x, Distance n, std::input_iterator_tag);

template<typename Iterator, typename Distance>
void advanceIterImpl(Iterator& x, Distance n, std::random_access_iterator_tag);
```

## SFINAE

SFINAE supports more advanced dispatching based on arbitrary sets of properties determined by type traits.

```cpp
template<typename Iterator, typename Distance>
EnableIf<IsRandomAccessIterator<Iterator>> advanceIter(Iterator& x, Distance n);
```

The problem is that the two constructor templates are identical except for the default template argument, but default template arguments are not considered when determining whether two templates are equivalent.

```cpp
// construct from an input iterator sequence
template<typename Iterator, typename = EnableIf<IsInputIterator<Iterator>>>
Container(Iterator first, Iterator last);
// ERROR: redeclaration of constructor template
template<typename Iterator, typename = EnableIf<IsRandomAccessIterator<Iterator>>>
Container(Iterator first, Iterator last); 
```

We can alleviate this problem by adding yet another defaulted template parameter.
```cpp
template<typename Iterator, typename = EnableIf<IsRandomAccessIterator<Iterator>>, typename = int> // extra dummy parameter to enable both constructors
Container(Iterator first, Iterator last);
```