# 模板继承

```{mermaid}
mindmap
模板继承
    EBCO
    CRTP
    Mixins
```

## Empty Base Class Optimization (EBCO)

Layout principle:
- empty classes have nonzero size, there are no zero-size types in C++
- the C++ standard does specify that when an empty class is used as a base class, no space needs to be allocated for it provided that it does not cause it to be allocated to the same address as another object or subobject of the same type.

Members as Base Classes
- template parameters are often substituted with empty class types

```cpp
template<typename CustomClass>
class Optimizable {
private:
    CustomClass info; // might be empty
    void* storage;
};

// make use of EBCO
template<typename CustomClass>
class Optimizable {
private:
    BaseMemberPair<CustomClass, void*> info_and_storage;
};

template<typename Base, typename Member>
class BaseMemberPair : private Base {
private:
    Member mem;
}
```

## Curiously Recurring Template Pattern (CRTP)

The base class can customize its own behavior to the derived class without requiring the use of virtual functions.

```cpp
template<typename Derived>
class CuriousBase {};

class Curious : public CuriousBase<Curious> {};
```

Example1:

```cpp
template<typename Derived>
class EqualityComparable
{
public:
    friend bool operator!= (Derived const& x1, Derived const& x2) {
        return !(x1 == x2);
    }
};

class X : public EqualityComparable<X>
{
public:
    friend bool operator== (X const& x1, X const& x2) {
        // implement logic for comparing two objects of type X
    }
};
```

Example2:

```cpp
template<typename Derived, typename Value, typename Category, typename Reference = Value&, typename Distance = std::ptrdiff_t>
class IteratorFacade
{
public:
    using value_type = typename std::remove_const<Value>::type;
    using reference = Reference;

    // input iterator interface:
    reference operator *() const { }
    pointer operator ->() const { }
    // ...

    // bidirectional iterator interface:
    Derived& operator --() { }
    Derived operator --(int) { }
    // ...

    // ...
};

template<typename T>
class ListNodeIterator : public IteratorFacade<ListNodeIterator<T>, T, std::forward_iterator_tag> {};
```

## Mixins