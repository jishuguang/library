# 模板继承

```{mermaid}
mindmap
模板继承
    EBCO
    CRTP
    Mixins
        CRTP-Mixin
    Type erasure
```

## Empty Base Class Optimization (EBCO)

Layout principle:
- empty classes have nonzero size, there are no zero-size types in C++
- the C++ standard does specify that when an empty class is used as a base class, no space needs to be allocated for it provided that it does not cause it to be allocated to the same address as another object or subobject of the same type.

Members as Base Classes
- template parameters are often substituted with empty class types

```cpp
template<typename CustomClass>
class Optimizable {
private:
    CustomClass info; // might be empty
    void* storage;
};

// make use of EBCO
template<typename CustomClass>
class Optimizable {
private:
    BaseMemberPair<CustomClass, void*> info_and_storage;
};

template<typename Base, typename Member>
class BaseMemberPair : private Base {
private:
    Member mem;
}
```

## Curiously Recurring Template Pattern (CRTP)

The base class can customize its own behavior to the derived class without requiring the use of virtual functions.

```cpp
template<typename Derived>
class CuriousBase {};

class Curious : public CuriousBase<Curious> {};
```

Example1:

```cpp
template<typename Derived>
class EqualityComparable
{
public:
    friend bool operator!= (Derived const& x1, Derived const& x2) {
        return !(x1 == x2);
    }
};

class X : public EqualityComparable<X>
{
public:
    friend bool operator== (X const& x1, X const& x2) {
        // implement logic for comparing two objects of type X
    }
};
```

Example2:

```cpp
template<typename Derived, typename Value, typename Category, typename Reference = Value&, typename Distance = std::ptrdiff_t>
class IteratorFacade
{
public:
    using value_type = typename std::remove_const<Value>::type;
    using reference = Reference;

    // input iterator interface:
    reference operator *() const { }
    pointer operator ->() const { }
    // ...

    // bidirectional iterator interface:
    Derived& operator --() { }
    Derived operator --(int) { }
    // ...

    // ...
};

template<typename T>
class ListNodeIterator : public IteratorFacade<ListNodeIterator<T>, T, std::forward_iterator_tag> {};
```

## Mixins

Mixins provide an alternative way to customize the behavior of a type without inheriting from it.

```cpp
template<typename... Mixins>
class Point : public Mixins...
{
public:
    double x, y;
    Point() : Mixins()..., x(0.0), y(0.0) { }
    Point(double x, double y) : Mixins()..., x(x), y(y) { }
};

class Label
{
public:
    std::string label;
    Label() : label("") { }
};
using LabeledPoint = Point<Label>;
```

### CRTP-Mixin

Each of the mixins is actually a class template that will be provided with the type of the derived class, allowing additional customization to that derived class.

```cpp
template<template<typename>... Mixins>
class Point : public Mixins<Point>...
{
public:
    double x, y;
    Point() : Mixins<Point>()..., x(0.0), y(0.0) { }
    Point(double x, double y) : Mixins<Point>()..., x(x), y(y) { }
};
```

## Type erasure

Type erasure provides some of the advantages of both static polymorphism and dynamic polymorphism, but the performance of generated code using type erasure hews more closely to that of dynamic polymorphism.

Example:

```cpp
// primary template:
template<typename Signature>
class FunctionPtr;

// partial specialization:
template<typename R, typename... Args>
class FunctionPtr<R(Args...)>
{
public:
    // The type is known only to the particular specialization of SpecificFunctorBridge. 
    // Once the newly allocated Bridge instance is assigned to the data member bridge, the extra information about the specific type F is lost.
    template<typename R, typename... Args>
    template<typename F>
    FunctionPtr<R(Args...)>::FunctionPtr(F&& f) : bridge(nullptr)
    {
        using Functor = std::decay_t<F>;
        using Bridge = SpecificFunctorBridge<Functor, R, Args...>;
        bridge = new Bridge(std::forward<F>(f));
    }

private:
    FunctorBridge<R, Args...>* bridge;
    // ......
};

// abstract class: dynamic polymorphism
template<typename R, typename... Args>
class FunctorBridge {
    virtual R invoke(Args... args) const = 0;
    // ......
}

template<typename Functor, typename R, typename... Args>
class SpecificFunctorBridge : public FunctorBridge<R, Args...> {
public:
    template<typename FunctorFwd> SpecificFunctorBridge(FunctorFwd&& functor) : functor(std::forward<FunctorFwd>(functor)) {}
    virtual R invoke(Args... args) const override;
    // ......
}
```