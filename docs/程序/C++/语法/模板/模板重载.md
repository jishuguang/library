# 模板重载

```{mermaid}
mindmap
模板重载
    Partial ordering
    Tag dispatching
    SFINAE
    Compile-Time if
    Concepts
```

## 基础

C++ does not currently provide any direct way to express overloads based on type properties.

```cpp
// the names of template parameters are ignored when comparing two function templates
// the two f function templates are actually declarations of the same function template
template<typename Number> void f(Number); // only for numbers
template<typename Container> void f(Container);// only for containers
```

The design and optimization approach of introducing more specialized variants of a generic algorithm is called *algorithm specialization*.

## Partial ordering

```cpp
// generic algorithm
template<typename T>
void swap(T& x, T& y)
{
    T tmp(x);
    x = y;
    y = tmp;
}

// more specialized based on the partial ordering rules for function templates, so the compiler will pick this when it is applicable
template<typename T>
void swap(Array<T>& x, Array<T>& y)
{
    swap(x.ptr, y.ptr);
    swap(x.len, y.len);
}
```

## Tag Dispatching

Tag dispatching supports simple dispatching based on hierarchical tags.

```cpp
template<typename Iterator, typename Distance>
void advanceIter(Iterator& x, Distance n)
{
    advanceIterImpl(x, n, typename std::iterator_traits<Iterator>::iterator_category());
}

template<typename Iterator, typename Distance>
void advanceIterImpl(Iterator& x, Distance n, std::input_iterator_tag);

template<typename Iterator, typename Distance>
void advanceIterImpl(Iterator& x, Distance n, std::random_access_iterator_tag);
```

## SFINAE

SFINAE supports more advanced dispatching based on arbitrary sets of properties determined by type traits.

```cpp
template<typename Iterator, typename Distance>
EnableIf<IsRandomAccessIterator<Iterator>> advanceIter(Iterator& x, Distance n);
```

The problem of the following code is that the two constructor templates are identical except for the default template argument, but default template arguments are not considered when determining whether two templates are equivalent.

```cpp
// construct from an input iterator sequence
template<typename Iterator, typename = EnableIf<IsInputIterator<Iterator>>>
Container(Iterator first, Iterator last);
// ERROR: redeclaration of constructor template
template<typename Iterator, typename = EnableIf<IsRandomAccessIterator<Iterator>>>
Container(Iterator first, Iterator last); 
```

We can alleviate this problem by adding yet another defaulted template parameter.
```cpp
template<typename Iterator, typename = EnableIf<IsRandomAccessIterator<Iterator>>, typename = int> // extra dummy parameter to enable both constructors
Container(Iterator first, Iterator last);
```

Unlike with overloaded function templates, we don’t need to disable any condition on the primary class template, because any partial specialization takes precedence over the primary template. However, we need to ensure that the conditions on the partial specializations are mutually exclusive.

```cpp
template<typename Key, typename Value, typename = void>
class Dictionary {};

template<typename Key, typename Value>
class Dictionary<Key, Value, EnableIf<HasLess<Key> && !HasHash<Key>>> {};

template<typename Key, typename Value>
class Dictionary<Key, Value, EnableIf<HasHash<Key>>> {};
```

## Compile-Time if

Using constexpr if in this way is only possible when the difference in the generic component can be expressed entirely within the body of the function template.

```cpp
template<typename Iterator, typename Distance>
void advanceIter(Iterator& x, Distance n) {
    if constexpr(IsRandomAccessIterator<Iterator>) {
    } else if constexpr(IsBidirectionalIterator<Iterator>) {
    } else {
    }
}
```

## Concepts

```cpp
template<typename Iterator>
requires IsInputIterator<Iterator>
void Container(Iterator first, Iterator last);
```